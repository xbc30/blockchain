## ABI
> ABI 全称是 Application Binary Interface(应用程序二进制接口)，是调用智能合约函数以及合约之间函数调用的消息编码格式定义,也可以理解为智能合约函数调用的接口说明. 类似Webservice里的SOAP协议一样；也就是定义操作函数签名，参数编码，返回结果编码等，格式简单的可以表示为: 函数选择器+参数编码

### 函数选择器

一个函数调用的前四个字节数据指定了要调用的函数签名。计算方式是使用函数签名的 keccak256 的哈希，取4个字节

```javascript
bytes4(keccak256("foo(uint32,bool)"))
```

函数名如果有多个参数使用,隔开，要去掉表达式中的所有空格。在geth客户端,通过命令可以得到hash:

```javascript
web3.sha3("foo(uint32,bool)")
"0xcc822237a37f9290b70dab4d640156d816bf8abdb959b5971d803a639dadef98" 
//截取前4个字节 即0xcc822237
```

### 参数编码

由于前面的函数签名使用了四个字节，参数的数据将从第五个字节开始。

根据参数类型,编码规则有所区别:

* uint<M>:M为integer类型代表M bits,0 < M <= 256 , M % 8 == 0，如uint32，uint8,uint256。
* int<M>:同上。同为从8到256位的无符号整数。
* uint和int:整型，分别是uint256和int256的别名。注意: 函数参数类型是uint，转sha3码时要变成uint256。
* address:地址，20个字节，160bits。
* bool:布尔类型，1个字节，true：1，false:0。
* bytes<M>:固定大小的字节数组，0<M<=32,byte都是bytes1的别名。
* bytes:动态分配大小字节数组。不是一个值类型!
* string:动态大小UTF8编码的字符串,不是一个值类型!

除了bytes,和string, 其他类型的数据不足32字节长度的需要加0补足32字节. 动态长度的编码在例子中介绍

### 举例

**案例一**

函数：baz(bytes3[2] memory)
调用：baz(69, true)

* 0xcdcd77c0，在node中使用new Web3().sha3('baz(uint32,bool)')生成

```javascript
const Web3 = require('web3')

const web3 = new Web3()
console.log(web3.sha3('f(uint256,uint32[],bytes10,bytes)'))
```

* 0x0000000000000000000000000000000000000000000000000000000000000045，十进制69，转成16进制为45，因为是正数，高位补0至32bytes

* 0x0000000000000000000000000000000000000000000000000000000000000001，bool类型，true=1，false=0，高位补0
所以最终字符串为

```javascript
0xcdcd77c0
0x0000000000000000000000000000000000000000000000000000000000000045
0x0000000000000000000000000000000000000000000000000000000000000001
```

返回：该函数返回的是true，output将会是

0x0000000000000000000000000000000000000000000000000000000000000000

**案例二**

函数：bar(bytes3[2] memory)
调用：bar(["abc", "def"])

* 0xfce353f6，在node中使用new Web3().sha3('bar(bytes3[2])')生成
固定长度不需要计算偏移量
* 0x6162630000000000000000000000000000000000000000000000000000000000，字符串abc转成16进制后为616263，低位补0，字符串转16进制可以使用这个工具
* 0x6465660000000000000000000000000000000000000000000000000000000000，同上

所以最终字符串为

```javascript
0xfce353f6
0x6162630000000000000000000000000000000000000000000000000000000000
0x6465660000000000000000000000000000000000000000000000000000000000
```

**案例三**

> 函数：f(uint,uint32[],bytes10,bytes)

> 调用：f(0x123, [0x456, 0x789], "1234567890", "Hello, world!")

* 0x8be65246，在node中使用f(uint256,uint32[],bytes10,bytes)生成
* 0x0000000000000000000000000000000000000000000000000000000000000123，0x123对应的16进制，正数补全
* 0x0000000000000000000000000000000000000000000000000000000000000080，动态类型，计算偏移量。这个的偏移量是指实际存储值的位置，由于这个函数有4个变量，那么实际存储值的位置就是第五个32bytes位置，也就是说偏移量等于4*32bytes=128，转成16进制后就是对应的值
* 0x3132333435363738393000000000000000000000000000000000000000000000，字符串1234567890转成16进制后为31323334353637383930，bytes类型，低位补全
* 0x00000000000000000000000000000000000000000000000000000000000000e0，动态类型，计算偏移量，这个偏移量就等于参数长度4*32bytes+前面的动态参数参数占有的长度（因为前面只有一个动态参数，所以这个长度就是1*32bytes+2*32bytes，1*32bytes是第一个动态参数长度所占的bytes数，2*32bytes是因为该函数中的第一个动态参数有2个值），那么具体的值就是 4*32bytes+(1*32bytes+2*32bytes)=7*32bytes=224，转成16进制就是e0，高位补全就是对应的值
* 0x0000000000000000000000000000000000000000000000000000000000000002，第一个动态参数的长度，长度为2
* 0x0000000000000000000000000000000000000000000000000000000000000456，第一个动态参数中的第一个元素
* 0x0000000000000000000000000000000000000000000000000000000000000789，第一个动态参数中的第二个元素
* 0x000000000000000000000000000000000000000000000000000000000000000d，第二个动态参数的长度，长度为13
* 0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000，第二个动态参数的值编码

所以最终字符串为:

```javascript
0x8be65246
0000000000000000000000000000000000000000000000000000000000000123
0000000000000000000000000000000000000000000000000000000000000080
3132333435363738393000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000e0
0000000000000000000000000000000000000000000000000000000000000002
0000000000000000000000000000000000000000000000000000000000000456
0000000000000000000000000000000000000000000000000000000000000789
000000000000000000000000000000000000000000000000000000000000000d
48656c6c6f2c20776f726c642100000000000000000000000000000000000000
```

### Web3.js中的函数

* web3.eth.abi.encodeFunctionSignature
* web3.eth.abi.encodeEventSignature
* web3.eth.abi.encodeParameter
* web3.eth.abi.encodeParameters
* web3.eth.abi.encodeFunctionCall
* web3.eth.abi.decodeParameter
* web3.eth.abi.decodeParameters
* web3.eth.abi.decodeLog
