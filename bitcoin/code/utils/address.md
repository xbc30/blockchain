## Address

### P2PKH
> 比特币的原始地址格式，P2PKH代表Pay-to-Pubkey Hash，即支付接收者公钥的哈希值，例如1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2

### P2SH
> P2SH代表对脚本哈希的支付，常用于隔离见证和多重签名，例如3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy

### bech32
> Bech32是本地segwit地址格式，并支持受到了广大的软件和硬件的钱包，每个都以“bc1”开头，并且由于此前缀而比传统或P2SH地址长，例如bc1qf3uwcxaz779nxedw0wry89v9cjh9w2xylnmqc3

地址以”bc1“开头。Bech32编码的地址，是专为SegWit开发的地址格式。Bech32在2017年底在BIP173被定义，该格式的主要特点之一是它不区分大小写（地址中只包含0-9，az），因此在输入时可有效避免混淆且更加易读。由于地址中需要的字符更少，地址使用Base32编码而不是传统的Base58，计算更方便、高效。数据可以更紧密地存储在二维码中。Bech32提供更高的安全性，更好地优化校验和错误检测代码，将出现无效地址的机会降到最低。

Bech32地址本身与SegWit兼容。不需要额外的空间来将SegWit地址放入P2SH地址，因此使用Bech32格式地址，手续费会更低。

Bech32地址比旧的Base58（Base58Check编码用于将比特币中的字节数组编码为人类可编码的字符串）地址有几个优点：

* QR码更小

* 更好地防错

* 更加安全

* 不区分大小写；

* 只由小写字母组成，所以在阅读、输入和理解时更容易

### 校验和地址

之前介绍了btc私钥公钥地址的生成，接下来介绍一下btc地址有效性的校验，要做地址有效性的校验，首先要知道他的地址生成规则：

第一步，随机选取一个32字节的数、大小介于1 ~ 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4141之间，作为私钥。
18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725

第二步，使用椭圆曲线加密算法（ECDSA-secp256k1）计算私钥所对应的非压缩公钥。 (共65字节， 1字节 0x04, 32字节为x坐标，32字节为y坐标）关于公钥压缩、非压缩的问题另文说明。

0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B
23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6

第三步，计算公钥的 SHA-256 哈希值
600FFE422B4E00731A59557A5CCA46CC183944191006324A447BDB2D98D4B408

第四步，取上一步结果，计算 RIPEMD-160 哈希值
010966776006953D5567439E5E39F86A0D273BEE

第五步，取上一步结果，前面加入地址版本号（比特币主网版本号“0x00”）
00010966776006953D5567439E5E39F86A0D273BEE

第六步，取上一步结果，计算 SHA-256 哈希值
445C7A8007A93D8733188288BB320A8FE2DEBD2AE1B47F0F50BC10BAE845C094

第七步，取上一步结果，再计算一下 SHA-256 哈希值（哈哈）
D61967F63C7DD183914A4AE452C9F6AD5D462CE3D277798075B107615C1A8A30

第八步，取上一步结果的前4个字节（8位十六进制）
D61967F6

第九步，把这4个字节加在第五步的结果后面，作为校验（这就是比特币地址的16进制形态）。
00010966776006953D5567439E5E39F86A0D273BEED61967F6

第十步，用base58表示法变换一下地址（这就是最常见的比特币地址形态）。
16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM

**校验流程:**

知道了生成流程，就好实现校验方法了。

第一步，先把地址base58解码成字节数组，然后把数组分成两个字节数组，一个是后4字节数组（字节数组1），一个是减去后4字节的数组（字节数组2），然后把字节数组2两次Sha256Hash，然后取其前4位，跟字节数组1比较，是相同的，就校验通过。

第二步，把第一步校验通过的解码字节数组取第一个字节&0xff，得到版本号，然后检验版本号的合法性（这个是根据主网参数校验的）